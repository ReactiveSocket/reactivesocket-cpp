// Copyright 2004-present Facebook. All Rights Reserved.

#include "src/RSocketClient.h"
#include "src/RSocketRequester.h"
#include "src/RSocketResponder.h"
#include "src/RSocketStats.h"
#include "src/internal/FollyKeepaliveTimer.h"
#include "src/internal/RSocketConnectionManager.h"
#include "src/framing/FrameTransport.h"
#include "src/framing/FramedDuplexConnection.h"

using namespace folly;

namespace rsocket {

RSocketClient::RSocketClient(
    std::unique_ptr<ConnectionFactory> connectionFactory)
    : connectionFactory_(std::move(connectionFactory)),
      connectionManager_(std::make_unique<RSocketConnectionManager>()) {
  VLOG(1) << "Constructing RSocketClient";
}

RSocketClient::~RSocketClient() {
  VLOG(1) << "Destroying RSocketClient";
}

folly::Future<std::unique_ptr<RSocketRequester>> RSocketClient::connect(
    SetupParameters setupParameters,
    std::shared_ptr<RSocketResponder> responder,
    std::unique_ptr<KeepaliveTimer> keepaliveTimer,
    std::shared_ptr<RSocketStats> stats,
    std::shared_ptr<RSocketNetworkStats> networkStats) {
  VLOG(2) << "Starting connection";

<<<<<<< HEAD
  folly::Promise<std::unique_ptr<RSocketRequester>> promise;
  auto future = promise.getFuture();

  connectionFactory_->connect([
    this,
    setupParameters = std::move(setupParameters),
    responder = std::move(responder),
    keepaliveTimer = std::move(keepaliveTimer),
    stats = std::move(stats),
    networkStats = std::move(networkStats),
    promise = std::move(promise)](
      std::unique_ptr<DuplexConnection> connection,
=======
  connectionFactory_->connect([this, promise = std::move(promise)](
      std::unique_ptr<DuplexConnection> connection,
      bool isFramedConnection,
>>>>>>> rewriting DuplexConnection to use yarpl Subscriber/Subscription interfaces
      folly::EventBase& eventBase) mutable {
    VLOG(3) << "onConnect received DuplexConnection";

    auto rsocket = fromConnection(
        std::move(connection),
        eventBase,
<<<<<<< HEAD
        std::move(setupParameters),
        std::move(responder),
        std::move(keepaliveTimer),
        std::move(stats),
        std::move(networkStats));
    promise.setValue(std::move(rsocket));
=======
        // need to allow Responder being passed in optionally
        std::make_shared<RSocketResponder>(),
        // need to allow stats being passed in
        RSocketStats::noop(),
        // TODO need to optionally allow defining the keepalive timer
        std::make_unique<FollyKeepaliveTimer>(
            eventBase, std::chrono::milliseconds(5000)),
        ReactiveSocketMode::CLIENT);

    // TODO need to allow this being passed in
    auto setupPayload =
        SetupParameters("text/plain", "text/plain", Payload("meta", "data"));

    // TODO ---> this code needs to be moved inside RSocketStateMachine

    rs->setFrameSerializer(
        setupPayload.protocolVersion == ProtocolVersion::Unknown
            ? FrameSerializer::createCurrentVersion()
            : FrameSerializer::createFrameSerializer(
                  setupPayload.protocolVersion));

    rs->setResumable(setupPayload.resumable);

    if (setupPayload.protocolVersion != ProtocolVersion::Unknown) {
      CHECK_EQ(
          setupPayload.protocolVersion, rs->getSerializerProtocolVersion());
    }

    std::unique_ptr<DuplexConnection> framedConnection;
    if(isFramedConnection) {
      framedConnection = std::move(connection);
    } else {
      framedConnection = std::make_unique<FramedDuplexConnection>(
          std::move(connection),
          setupPayload.protocolVersion);
    }

    auto frameTransport =
        yarpl::make_ref<FrameTransport>(std::move(framedConnection));
    rs->setUpFrame(std::move(frameTransport), std::move(setupPayload));

    // TODO <---- up to here
    // TODO and then a simple API such as:
    // TODO rs->connectAndSendSetup(frameTransport, params, setupPayload)

    auto rsocket = RSocketRequester::create(std::move(rs), eventBase);
    // store it so it lives as long as the RSocketClient
    rsockets_.push_back(rsocket);
    promise->setValue(rsocket);
>>>>>>> rewriting DuplexConnection to use yarpl Subscriber/Subscription interfaces
  });

  return future;
}

std::unique_ptr<RSocketRequester> RSocketClient::fromConnection(
    std::unique_ptr<DuplexConnection> connection,
    folly::EventBase& eventBase,
    SetupParameters setupParameters,
    std::shared_ptr<RSocketResponder> responder,
    std::unique_ptr<KeepaliveTimer> keepaliveTimer,
    std::shared_ptr<RSocketStats> stats,
    std::shared_ptr<RSocketNetworkStats> networkStats) {
  CHECK(eventBase.isInEventBaseThread());

  if (!responder) {
    responder = std::make_shared<RSocketResponder>();
  }

  if (!keepaliveTimer) {
    keepaliveTimer = std::make_unique<FollyKeepaliveTimer>(
        eventBase, std::chrono::milliseconds(5000));
  }

  if (!stats) {
    stats = RSocketStats::noop();
  }

  auto rs = std::make_shared<RSocketStateMachine>(
      eventBase,
      std::move(responder),
      std::move(keepaliveTimer),
      ReactiveSocketMode::CLIENT,
      std::move(stats),
      std::move(networkStats));

  connectionManager_->manageConnection(rs, eventBase);

  rs->connectClientSendSetup(std::move(connection), std::move(setupParameters));
  return std::make_unique<RSocketRequester>(std::move(rs), eventBase);
}

}
